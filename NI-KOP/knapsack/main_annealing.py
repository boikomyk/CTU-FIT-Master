#coding: utf-8

import argparse
from timeit import default_timer as timer

# import helpers
from benchmark.complexity import Complexity
from helpers.loader import Loader
from helpers.logger import Logger, LOG_EVENTS

# import resolvers
from helpers.utils import is_dir_or_file_path
from resolvers.algorithms.annealing_functions import InitialStateGenerator, AnnealingFunctions
from resolvers.algorithms.simulated_annealing import SimulatedAnnealing
from resolvers.resolver_common import compare_solution_with_reference

from benchmark.benchmark import Benchmark

def main():
    # Init CLI and proceed input args
    parser = init_cli()
    args = parser.parse_args()

    # Load input files and wrap them into objects
    knapsack_sets_list = Loader.load_input_data(
        path=args.input,
        max_cnt_to_read=args.count
    )


    # Solve
    solutions_and_complexities_lists = list()

    for knapsack_set in knapsack_sets_list:
        solutions_and_complexities_list = list()

        for knapsack in knapsack_set.knapsack_list:
            if LOG_EVENTS:
                Logger.log_warning(f"Initial state is generated by '{args.state_generator.name}'")
            # Generate and set initial state:
            # - empty knapsack
            # - randomly filled knapsack
            # - filled knapsack using Greedy algorithms
            if args.state_generator == InitialStateGenerator.random:
                initial_state = AnnealingFunctions.generate_state_by_random(knapsack=knapsack)
            elif args.state_generator == InitialStateGenerator.greedy:
                initial_state = AnnealingFunctions.generate_state_by_greedy(knapsack=knapsack)
            else:
                initial_state = AnnealingFunctions.generate_state_empty(knapsack=knapsack)

            begin = timer()
            simulated_annealing = SimulatedAnnealing(
                # set parameters
                knapsack=knapsack,
                initial_state=initial_state,
                initial_temperature=args.initial_temperature,
                cooling_coefficient=args.cooling_coefficient,
                minimal_temperature=args.minimal_temperature,
                equilibrium_coefficient=args.equilibrium_coefficient
            )
            if LOG_EVENTS:
                print(simulated_annealing)
            # start SimulatedAnnealing
            configurations_cnt, solved_instance = simulated_annealing.run_sa()
            end = timer()

            # seconds * 1000000 (6x0) = microseconds
            execution_time = (end - begin) * 1000000

            # create tuple containing solved instance and it's complexity
            solution_and_complexity = (solved_instance, Complexity(
                execution_time=execution_time,
                configurations_cnt=configurations_cnt
            ))
            solutions_and_complexities_list.append(solution_and_complexity)

        solutions_and_complexities_lists.append((knapsack_set.id, solutions_and_complexities_list))

    # Load references
    if args.reference is not None:
        proceed_dataset_names = [i[0] for i in solutions_and_complexities_lists]
        if LOG_EVENTS: Logger.log_info('reading references')
        references_dict = Loader.read_references(
            path_to_ref=args.reference,
            proceeded_dataset_names=proceed_dataset_names
        )

        # Compare with references
        if references_dict is not None:
            if LOG_EVENTS: Logger.log_info('comparing with references')
            compare_solution_with_reference(
                solutions_and_complexities_lists=solutions_and_complexities_lists,
                references_dict=references_dict
            )
        else:
            if LOG_EVENTS: Logger.log_warning('According references were not found')
    else:
        if LOG_EVENTS: Logger.log_warning('Path with references isn\'t set')

    # Start benchmark
    if args.benchmark:
        Benchmark.do_benchmark(solutions_and_complexities_lists)


def init_cli() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(description='Process input problem instances.')
    """
     0) - --count : count of files to proceed
     1) - --input : path to the dir with testing files
     2) - --reference: path to the dir with references
     3) - --benchmark: turn on/off benchmark
    """
    parser.add_argument('-cnt', '--count', type=int, default=24)
    parser.add_argument('-in', '--input', type=is_dir_or_file_path, help='paste path to input files')
    parser.add_argument('-ref', '--reference', type=is_dir_or_file_path, help='paste path with references')
    parser.add_argument('-b', '--benchmark', action='store_true', help='turn on/off benchmark')

    """
     4) - --state_generator 
     5) - --initial_temperature 
     6) - --cooling_coefficient
     7) - --minimal_temperature
     4) - --equilibrium_coefficient
    """
    parser.add_argument('-state_generator', '--state_generator', type=lambda generator: InitialStateGenerator[generator], choices=list(InitialStateGenerator), default=InitialStateGenerator.empty)
    parser.add_argument('-initial_temperature', '--initial_temperature', type=float, help='initial temperature', default=100)
    parser.add_argument('-cooling_coefficient', '--cooling_coefficient', type=float, help='cooling coefficient', default=0.92)
    parser.add_argument('-minimal_temperature', '--minimal_temperature', type=float, help='minimal temperature', default=30)
    parser.add_argument('-equilibrium_coefficient', '--equilibrium_coefficient', type=float, help='equilibrium coefficient', default=30)
    return parser


if __name__ == '__main__':
    main()
